/*
    SecuNik LogX - Exploit Pattern Detection Rules
    Author: SecuNik LogX Team
    Date: 2024-01-01
    Description: Detection rules for various exploitation techniques including buffer overflows, shellcode, and exploit kits
*/

import "pe"
import "math"

// ============= SHELLCODE DETECTION =============

rule Shellcode_x86_Generic : shellcode exploit
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects common x86 shellcode patterns"
        severity = "high"
        
    strings:
        // Common x86 shellcode prologue
        $prologue1 = { FC E8 ?? 00 00 00 }  // cld; call
        $prologue2 = { E8 00 00 00 00 5? }  // call; pop
        $prologue3 = { EB ?? 5? }           // jmp short; pop
        
        // GetPC techniques
        $getpc1 = { E8 00 00 00 00 58 }     // call $+5; pop eax
        $getpc2 = { E8 00 00 00 00 5B }     // call $+5; pop ebx
        
        // Common API hashing
        $api_hash = { 8B ?? 30 0C 39 8B ?? 1C }
        
        // WinExec shellcode pattern
        $winexec = { 6A 00 68 65 78 65 20 68 63 6D 64 2E 8D }
        
        // Common egg hunter
        $egghunter = { 66 81 CA FF 0F 42 52 6A 02 58 CD 2E }
        
    condition:
        any of ($prologue*) or
        any of ($getpc*) or
        $api_hash or
        $winexec or
        $egghunter
}

rule Shellcode_x64_Generic : shellcode exploit
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects common x64 shellcode patterns"
        severity = "high"
        
    strings:
        // x64 shellcode patterns
        $prologue_x64 = { FC 48 83 E4 F0 }              // cld; and rsp, 0xfffffffffffffff0
        $api_call = { FF D? }                            // call reg
        $syscall = { 0F 05 }                             // syscall
        
        // Position independent code
        $pic_x64 = { 48 8D ?? ?? ?? ?? ?? }             // lea reg, [rip+...]
        
        // Common x64 WinExec pattern
        $winexec_x64 = { 48 83 EC 28 48 83 E4 F0 48 8D }
        
        // x64 egg hunter
        $egghunter_x64 = { 48 31 DB 48 F7 E3 66 81 CA FF 0F }
        
    condition:
        $prologue_x64 or
        ($api_call and $syscall) or
        $pic_x64 or
        $winexec_x64 or
        $egghunter_x64
}

rule Shellcode_Encoded_XOR : shellcode exploit
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects XOR encoded shellcode"
        severity = "high"
        
    strings:
        // XOR decoder stubs
        $xor_stub1 = { 80 30 ?? 40 3D ?? ?? ?? ?? 72 F5 }  // xor byte [eax], key; inc eax; cmp eax, size; jb
        $xor_stub2 = { 80 34 01 ?? 41 81 F9 ?? ?? ?? ?? 72 F3 }  // xor byte [ecx+eax], key; inc ecx
        $xor_stub3 = { 31 ?? 83 ?? ?? 83 ?? ?? 75 }        // xor [reg], reg; add reg, 4; cmp reg, val; jne
        
        // Common XOR keys
        $xor_pattern1 = { ( 90 | A0 | B0 | C0 | D0 | E0 | F0 ) [50-500] ( 90 | A0 | B0 | C0 | D0 | E0 | F0 ) }
        
    condition:
        any of ($xor_stub*) or
        $xor_pattern1
}

// ============= BUFFER OVERFLOW PATTERNS =============

rule BufferOverflow_NOP_Sled : exploit overflow
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects NOP sled patterns used in buffer overflows"
        severity = "high"
        
    strings:
        // x86 NOP sleds
        $nop_90 = { 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 90 }
        $nop_cc = { CC CC CC CC CC CC CC CC CC CC CC CC CC CC CC CC }
        
        // Alternative NOP patterns
        $nop_alt1 = { 40 40 40 40 40 40 40 40 }  // inc eax
        $nop_alt2 = { 41 41 41 41 41 41 41 41 }  // inc ecx
        $nop_alt3 = { 42 42 42 42 42 42 42 42 }  // inc edx
        
        // x64 NOP patterns
        $nop_x64 = { 48 90 48 90 48 90 48 90 }   // rex.w nop
        
    condition:
        any of them
}

rule BufferOverflow_SEH_Overwrite : exploit overflow
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects SEH overwrite patterns"
        severity = "high"
        
    strings:
        // Common SEH overwrite patterns
        $seh_pattern1 = { EB 06 90 90 ?? ?? ?? ?? }  // jmp 06; nop nop; address
        $seh_pattern2 = { EB 10 90 90 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? }
        
        // POP POP RET gadgets
        $ppr1 = { 58 58 C3 }  // pop eax; pop eax; ret
        $ppr2 = { 5B 5B C3 }  // pop ebx; pop ebx; ret
        $ppr3 = { 59 59 C3 }  // pop ecx; pop ecx; ret
        
    condition:
        any of ($seh_pattern*) or
        any of ($ppr*)
}

// ============= ROP CHAIN DETECTION =============

rule Exploit_ROP_Chain_Patterns : exploit rop
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects Return Oriented Programming chains"
        severity = "high"
        
    strings:
        // Common ROP gadgets
        $gadget1 = { 58 C3 }        // pop eax; ret
        $gadget2 = { 5B C3 }        // pop ebx; ret
        $gadget3 = { 59 C3 }        // pop ecx; ret
        $gadget4 = { 5A C3 }        // pop edx; ret
        $gadget5 = { 94 C3 }        // xchg eax, esp; ret
        $gadget6 = { 87 E4 C3 }     // xchg esp, eax; ret
        
        // ROP chain pattern (series of addresses)
        $rop_chain = { [4] [4] [4] [4] [4] [4] [4] [4] }
        
    condition:
        #gadget1 > 5 or #gadget2 > 5 or #gadget3 > 5 or
        (#gadget5 > 0 and #gadget6 > 0) or
        ($rop_chain and for all i in (0..7) : (uint32(@rop_chain + i*4) & 0xFF000000 == 0x00000000))
}

// ============= HEAP SPRAY DETECTION =============

rule Exploit_HeapSpray_Pattern : exploit heapspray
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects heap spray patterns"
        severity = "high"
        
    strings:
        // Heap spray NOP + shellcode pattern
        $spray_pattern1 = { 0C 0C 0C 0C 0C 0C 0C 0C }
        $spray_pattern2 = { 0D 0D 0D 0D 0D 0D 0D 0D }
        $spray_pattern3 = { 90 90 90 90 90 90 90 90 [100-300] ( FC | E8 | EB ) }
        
        // Common spray addresses
        $spray_addr1 = { 0C 0C 0C 0C }
        $spray_addr2 = { 0A 0A 0A 0A }
        $spray_addr3 = { 08 08 08 08 }
        
    condition:
        (#spray_pattern1 > 100) or
        (#spray_pattern2 > 100) or
        $spray_pattern3 or
        (for any of ($spray_addr*) : (# > 50))
}

// ============= POWERSHELL EXPLOITS =============

rule PowerShell_Exploit_Patterns : exploit powershell
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects PowerShell exploitation patterns"
        severity = "high"
        
    strings:
        // Encoded commands
        $encoded1 = "-EncodedCommand" nocase
        $encoded2 = "-enc" nocase
        $encoded3 = "-e " nocase
        
        // Common exploit patterns
        $invoke_expr = "Invoke-Expression" nocase
        $iex = "IEX" nocase
        $download = "Net.WebClient" nocase
        $download2 = "DownloadString" nocase
        $download3 = "DownloadFile" nocase
        
        // Obfuscation
        $obfusc1 = {2D 00 65 00 ( 63 | 43 ) 00}  // -e[cC] in Unicode
        $obfusc2 = "[char[]]" nocase
        $obfusc3 = "-join" nocase
        
        // Memory injection
        $inject1 = "VirtualAlloc" nocase
        $inject2 = "Marshal]::Copy" nocase
        $inject3 = "CreateThread" nocase
        
    condition:
        (any of ($encoded*) and (any of ($invoke_expr, $iex))) or
        ($download and any of ($download2, $download3)) or
        (any of ($obfusc*) and any of ($inject*))
}

// ============= OFFICE MACRO EXPLOITS =============

rule Office_Macro_Exploit_Patterns : exploit macro
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects malicious Office macro patterns"
        severity = "high"
        
    strings:
        // Auto execution
        $auto1 = "Auto_Open" nocase
        $auto2 = "AutoOpen" nocase
        $auto3 = "Document_Open" nocase
        $auto4 = "Workbook_Open" nocase
        
        // Shell execution
        $shell1 = "Shell" nocase
        $shell2 = "WScript.Shell" nocase
        $shell3 = "cmd.exe" nocase
        $shell4 = "powershell" nocase
        
        // Download patterns
        $download1 = "URLDownloadToFile" nocase
        $download2 = "MSXML2.XMLHTTP" nocase
        $download3 = "WinHttp.WinHttpRequest" nocase
        
        // Obfuscation
        $obfusc1 = "Chr(" nocase
        $obfusc2 = "ChrW(" nocase
        $obfusc3 = "StrReverse" nocase
        
    condition:
        (any of ($auto*) and any of ($shell*)) or
        (any of ($auto*) and any of ($download*)) or
        (any of ($shell*) and any of ($obfusc*))
}

// ============= EXPLOIT KIT DETECTION =============

rule ExploitKit_Angler_Patterns : exploit kit
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects Angler exploit kit patterns"
        severity = "high"
        
    strings:
        $angler1 = "AnglerEK" nocase
        $angler2 = "/forum/view.php?t=" nocase
        $angler3 = "application/x-shockwave-flash" nocase
        $landing = /<script>var [a-z]=[a-z]\([0-9]+\);/
        $obfusc = /eval\(unescape\(['"][%0-9a-f]+['"]\)\)/
        
    condition:
        any of ($angler*) or
        ($landing and $obfusc)
}

rule ExploitKit_Generic_Patterns : exploit kit
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Generic exploit kit detection patterns"
        severity = "medium"
        
    strings:
        // Common exploit kit patterns
        $pattern1 = "PluginDetect" nocase
        $pattern2 = "deployJava.js" nocase
        $pattern3 = "Adobe Reader" nocase
        
        // Version detection
        $version1 = /navigator\.plugins\[['"](.*?)['"]\]/
        $version2 = /new ActiveXObject\(['"](.*?)['"]\)/
        
        // Obfuscation patterns
        $obfusc1 = /String\.fromCharCode\([0-9,\s]+\)/
        $obfusc2 = /unescape\(['"]\%[0-9a-f]+['"]\)/
        $obfusc3 = /eval\([a-z]+\[[0-9]+\]\+[a-z]+\[[0-9]+\]/
        
    condition:
        (2 of ($pattern*)) or
        (any of ($version*) and any of ($obfusc*))
}

// ============= CVE SPECIFIC EXPLOITS =============

rule Exploit_EternalBlue_MS17_010 : exploit cve
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects EternalBlue exploit patterns"
        reference = "CVE-2017-0144"
        severity = "critical"
        
    strings:
        $smb_exploit = { FF 53 4D 42 72 00 00 00 00 18 53 C8 00 00 00 00 }
        $doublepulsar = "DOUBLEPULSAR" ascii
        $trans2 = { 00 00 00 00 00 00 00 00 00 00 00 00 00 00 FF FE }
        $payload_marker = { 57 6F 72 6B 65 72 20 70 72 6F 63 65 73 73 }
        
    condition:
        $smb_exploit or $doublepulsar or 
        ($trans2 and $payload_marker)
}

rule Exploit_PrintNightmare_CVE_2021_34527 : exploit cve
{
    meta:
        author = "SecuNik LogX"
        date = "2024-01-01"
        description = "Detects PrintNightmare exploit attempts"
        reference = "CVE-2021-34527"
        severity = "critical"
        
    strings:
        $rpc1 = "RpcAddPrinterDriverEx" ascii
        $rpc2 = "\\\\evil\\driver" nocase
        $dll_path = /\\\\[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\\[a-zA-Z0-9]+\\[a-zA-Z0-9]+\.dll/
        $spoolsv = "spoolsv.exe" nocase
        
    condition:
        ($rpc1 and $dll_path) or
        ($rpc2 and $spoolsv)
}